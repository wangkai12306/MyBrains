title: Java基础
---

## 关键字
#### 类,方法和变量修饰符
1. **abstract:** 可以修饰类或者方法
2. **class:**
3. **extends:**
4. **final:**
  - 可以修饰类，方法，变量(成员变量和局部变量)
  - final修饰了类，那么将不能被继承，所以方法也将隐式地被final修饰
  - private也会隐式的将方法指定为final
  - final修饰的变量将不能被修改
  - 被static和final修饰的变量，将会占据一段不能改变的存储空间，将会被看做编译期常量
5. **implements:**
6. **interface:**
7. **native:**
8. **new:**
9. **static:** 
  _成员变量_
  - 被static修饰的类的变量不依赖与任何对象，所以可以直接用类名调用(当然也可以通过对象调用)
  - 静态变量被所有的对象所共享，在内存中只有一个副本(存放在方法区)，仅在类加载时初始化(是否加final存放位置不一样)
  - 非静态变量是各对象独有的，在创建对象时初始化，有多个副本，互不影响
  - 静态变量按照定义的顺序初始化
  - static不能修饰局部变量
  
  _成员方法_
  - 静态方法内不可以使用this，不能直接调用非静态方法(必须用对象调用)和非静态成变量
  - 非静态方法可以访问静态变量和静态方法
  
  _代码块_
  - static块可置于类的任何位置，类加载时执行代码块，`只执行一次`(根据class加载原理 每个类加载一次 使用[双亲委托](jvm.html)加载)
  - 初始化顺序：static变量->static块->构造块->构造函数
  
  _import_
  _ import static com.xxx.ClassName.staticMethod，可以直接导入类的静态方法

10. **strictfp:**
11. **synchronized:**
12. **transient:**
13. **volatile:** 被volatile修饰的变量在执行时不会重排序，可以保证[可见性](jvm.html)
  - 编译器和运行时对volatile的操作都在内存中，读取时保证返回最新值，因为内存是被所有线程所共享的
  - volatile变量不会利用寄存器或Cache，因为它们都不是全局的，无法保证可见性，可能产生脏读，这里的代价就是牺牲了性能
  - 访问volatile变量时不会加锁，因此不对阻塞执行的线程，是一种比synchronized更轻量的同步机制
  - 读性能与普通变量几乎相同，但写性能稍差，因为它需要插入内存屏障的指令来保证编译器不重排序
  > 线程操作普通变量时先从内存copy到缓存里，再执行后续操作。而缓存不是全局的，且不会即时刷新到内存。每个线程都有自己的缓存，这样就无法保证可见性

#### 程序控制
1. **break:**
2. **continue:**
3. **return:**
4. **do:**
5. **while:**
6. **if:**
7. **else:**
8. **for:**
9. **instanceof:**
10. **switch:**
11. **case:**
12. **default:**

#### 错误处理
1. **try:**
2. **catch:**
3. **throw:**
4. **throws:**

#### 包相关
1. **import:**
2. **package:**

#### 基本类型
1. **boolean:**
2. **byte:**
3. **char:**
4. **double:**
5. **float:**
6. **int:**
7. **long:**
8. **short:**
9. **null:**
10. **true:**
11. **false:**

#### 变量引用
1. **super:**
2. **this:**
3. **void:**

#### 保留字
1. **goto:**
2. **const:**