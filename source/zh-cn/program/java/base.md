title: Java基础
---
# Object
Object在Java里是所有类的父类，其提供了一些共同方法如下
## getClass
动态获取当前对象的类型信息。该方法被final和native修饰，即不能被重写，且是有其他语言实现的。返回Class<?>后就可以利用Java的反射机制进行其他操作
> 由于成员内部类持有外部类对象的引用，反射获取类型信息的方式和静态内部类不同，详细请参考[反射内部类](reflect.html#内部类)

## hasCode
## equals
本意是判断两个对象的值是否相同，但源码里是判断两个对象但引用是否相同，所以该方法大多数情况下都需要重写
## clone
获取当前对象的复制品(浅拷贝)。自定义类型要支持clone方法，必须实现Cloneable接口
### 浅拷贝
1. 基本类型：直接将值传递给新对象，其中一个修改，另一个不会改变
2. 引用类型：复制对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化
### 深拷贝
不仅要拷贝对象里面的属性值，还要开辟新的内存空间，所以内存地址不同(可以通过重写clone方法实现)

## toString
返回对象的字符串表示
Object中的默认实现是`对象的类名@对象的hashCode的十六进制`，通常我们需要重写

## wait
使当前线程让出持有的对象锁并进入阻塞状态，重载的带参的方法可以控制阻塞时间，当然也可以随时用`notify`来唤醒

## notify
随机唤醒一个因为调用了当前对象的wait方法而陷入阻塞的线程

## notifyAll
唤醒全部因为调用了当前对象的`wait`方法而陷入阻塞的线程

## finalize
JVM在进行垃圾回收时`可能`会调用的方法，详细请参考[垃圾回收](jvm.html#垃圾回收)


# 类
## 内部类
***定义在其他类内部或者方法内部的类***
### 为什么有内部类
1. 内部类可以访问外部类的成员变量和成员方法
2. 内部类可以实现多继承
3. private修饰可以对外隐藏，外部类不能用private和protected修饰

### 内部类的分类
##### 普通内部类
1. 可以访问外部类的所有成员变量和成员方法，无论是否有private或者static修饰
2. `不可以`声明静态成员变量和成员方法(普通内部类的创建`依赖`外部类实例)
3. 如果内部类和外部类的变量或方法同名，那么在内部类里外部类的变量或方法须通过`OutClass.this.xxx`调用，否则将隐藏
4. 外部类要访问内部类必须先实例化
5. 内部类对象会持有外部类对象的引用

##### 静态内部类
1. 只能访问外部类的静态成员变量和成员方法
2. `可以`声明静态成员变量和成员方法(`不依赖`于外部类)

##### 匿名内部类
常用于接口实现
```java
Interface i = new Interface() {
    @Override
    public void function() {
    }
};
```
##### 局部内部类
声明于方法内的类，和内部类一样可以访问外部类所有变量和方法，但外部类不能访问局部内部类

> **非静态**内部类与外部类互相访问私有成员时，二者在编译期均会生成一个静态方法(access$xxx)用来返回私有成员给对方。内部类会持有外部类对象的引用
> 外部类可以访问**静态**内部类的私有成员变量

>一般只有在两个类有强依赖关系或专门辅助但特性时才会用内部类和外部类的形式，否则最好一个java文件对应一个类

## 虚拟类

# 关键字
### 类,方法和变量修饰符
1. **abstract:** 可以修饰类或者方法
2. **class:**
3. **extends:**
4. **final:**
  - 可以修饰类，方法，变量(成员变量和局部变量)
  - final修饰了类，那么将不能被继承，所以方法也将隐式地被final修饰
  - private也会隐式的将方法指定为final
  - final修饰的变量将不能被修改
  - 被static和final修饰的变量，将会占据一段不能改变的存储空间，将会被看做编译期常量
5. **implements:**
6. **interface:**
7. **native:**
8. **new:**
9. **static:** 
  _成员变量_
  - 被static修饰的类的变量不依赖与任何对象，所以可以直接用类名调用(当然也可以通过对象调用)
  - 静态变量被所有的对象所共享，在内存中只有一个副本(存放在方法区)，仅在类加载时初始化(是否加final存放位置不一样)
  - 非静态变量是各对象独有的，在创建对象时初始化，有多个副本，互不影响
  - 静态变量按照定义的顺序初始化
  - static不能修饰局部变量
  
  _成员方法_
  - 静态方法内不可以使用this，不能直接调用非静态方法(必须用对象调用)和非静态成变量
  - 非静态方法可以访问静态变量和静态方法
  
  _代码块_
  - static块可置于类的任何位置，类加载时执行代码块，`只执行一次`(根据class加载原理 每个类加载一次使用[双亲委托](jvm.html#类加载)加载)
  - 初始化顺序：static变量->static块->构造块->构造函数
  
  _import_
  _ import static com.xxx.ClassName.staticMethod，可以直接导入类的静态方法

10. **strictfp:**
11. **synchronized:**
12. **transient:**
13. **volatile:** 被volatile修饰的变量在执行时不会重排序，可以保证[可见性](jvm.html#基本概念)
  - 编译器和运行时对volatile的操作都在内存中，读取时保证返回最新值，因为内存是被所有线程所共享的
  - volatile变量不会利用寄存器或Cache，因为它们都不是全局的，无法保证可见性，可能产生脏读，这里的代价就是牺牲了性能
  - 访问volatile变量时不会加锁，因此不对阻塞执行的线程，是一种比synchronized更轻量的同步机制
  - 读性能与普通变量几乎相同，但写性能稍差，因为它需要插入内存屏障的指令来保证编译器不重排序
  > 线程操作普通变量时先从内存copy到缓存里，再执行后续操作。而缓存不是全局的，且不会即时刷新到内存。每个线程都有自己的缓存，这样就无法保证可见性

### 程序控制
1. **break:**
2. **continue:**
3. **return:**
4. **do:**
5. **while:**
6. **if:**
7. **else:**
8. **for:**
9. **instanceof:**
10. **switch:**
11. **case:**
12. **default:**

### 错误处理
1. **try:**
2. **catch:**
3. **throw:**
4. **throws:**

### 包相关
1. **import:**
2. **package:**

### 基本类型
1. **boolean:**
2. **byte:**
3. **char:**
4. **double:**
5. **float:**
6. **int:**
7. **long:**
8. **short:**
9. **null:**
10. **true:**
11. **false:**

### 变量引用
1. **super:**
2. **this:**
3. **void:**

### 保留字
1. **goto:**
2. **const:**